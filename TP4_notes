  Part II :  Bolivian and Peruvian train
//_______   ____________________________

Qust 2.1
The peruvian schedule might make sure to arrive first, then every time the bolivian 
driver is sleeping a new peruvian driver arrives and drops the pebble in the bowl.


Qust 2.2

// Shared variable
int check = 0 ;

void enter_cs(){
	while ( check != 0 ){
		sleep( rand() % 10 ); // We don't know the sleeping time
	}
	check = 1 ;
	// Execution
	// Access cs
	}

}

void leave_cs(){
	check = 0 ;
}

int main(){
	// Enter CS
	enter_cs() ;
	// execution in sc
	leave_cs()
	
	return 0 ;
}


Qust 2.3

The problem was never observed, it is so inprobable for another train to arrive 
every single time at during the sleeping stage of the other driver. It may happen
several times, but this occuring forever has a very low proba of happening


Qust 2.4
The problem is the need for critical sections

Qust 2.5
Liveness

Qust 2.6
Both trains arrive at the same time, they both put a pebble in the bowl at the same time,
then both try access the pass.

Both threads they check check == 0 condition, both can enter the cs, thus we have both threads accessing cs
at the same time


Qust 2.7
T1 might get blocked in enter_cs() if T0, does not want to enter.

Qust 2.8
Both threads can put wants[ my_id ] to 1 at the same time. In this case, they both enter a sleeping phase.




  Part III : Implementing a barrier with semaphores
//_______    _______________________________________

Qust 3.9

Rappel : 

	int sem_wait(sem_t *sem)
		decrements (locks) the semaphore pointed to by sem.  If the semaphore's value is greater than zero,
		then the decrement proceeds, and the function returns, immediately.  If the semaphore currently has 
		the value zero, then the call blocks until either it becomes possible to perform the decrement 
		(i.e.,the semaphore  value  rises above zero), or a signal handler interrupts the call.


	int sem_post(sem_t *sem);
	DESCRIPTION
		sem_post() increments (unlocks) the semaphore pointed to by sem.  If the semaphore's value consequently 
		becomes greater than zero, then another process or thread blocked in a sem_wait(3) call will be woken up 
		and proceed to lock the semaphore.


-->
S_A , S_B : initial value = 0 ;


// Thread A
IA1 ;
// A_sync
	sem_post( S_A ) ; // Now we have : C_A = 1 ; ( C_A is the counting var in sem_post() )
	sem_wait( S_B ) ; // A is waiting for B
// End of sync
IA2;


// Thread B
IA1 ;
// A_sync
	sem_post( S_B ) ; // C_B = 1, and unlocks A 
	sem_wait( S_A ) ; // Will check if C_A <= ; it waits
			  // It passes directly
// End of sync
IA2;




  Part IV : Semaphores vs condition vars
//_______    _______________________________________

Qust 4.10

	mutex_t mutex = M_INIT ;
	cond_t sem_event = C_INIT ;
	void sem_init( int N ){
		sem_capacity = N ;
	}
	void P ( void ){
		mutex_lock( &mutex );
		sem_capacity-- ;
		if ( sem_capacity < 0 ){
			cond_wait( &sem_event , &mutex ) ;
		}
		mutex_unlock( &mutex ) ;
	}
	
	// The better version
	/* 
	In this case we don't allow the capacity to be < 0. 
	In the first function, a capacity < 0 represents the 
	number of threads waiting.
	
	// Spurious wakeups
	*/	
	void P ( void ){
		mutex_lock( &mutex );
		while ( sem_capacity == 0 ){
			cond_wait( &sem_event , &mutex ) ;
		} 
		sem_capacity-- ;
		mutex_unlock( &mutex ) ;
	}

	void V( void ){
		mutex_lock( &mutex ) ;
		sem_capacity++ ;
		cond_signal( &sem_event );
		mutex_unlock( &mutex );	
	} 



Part V :	Semaphores vs Condition Variables (2nd round)
//_______    	______________________________________________

Qust 5.11-


//	______________________________________________
Rappel : 

	int sem_wait(sem_t *sem)
		decrements (locks) the semaphore pointed to by sem.  If the semaphore's value is greater than zero,
		then the decrement proceeds, and the function returns, immediately.  If the semaphore currently has 
		the value zero, then the call blocks until either it becomes possible to perform the decrement 
		(i.e.,the semaphore  value  rises above zero), or a signal handler interrupts the call.


	int sem_post(sem_t *sem);
	DESCRIPTION
		sem_post() increments (unlocks) the semaphore pointed to by sem.  If the semaphore's value consequently 
		becomes greater than zero, then another process or thread blocked in a sem_wait(3) call will be woken up 
		and proceed to lock the semaphore.
//	______________________________________________
		

	sem_t s ;
	void init(){
		sem_init( &s , 0 ) ;	
	}
	
	void get_new_click_event(){
		/*
		• 	void get_new_click(void): Returns only when a click event is available. By available,
			we mean that each click can be associated with a single call to get_new_click(). We also
			mean that no event is lost, that is, if there is a new click event while no thread is blocked in
			the get_new_click() function, then the next thread calling get_new_click() will not
			block.
		*/
		sem_wait( &s ) ;
	}
	
	void new_click_event(){
		// • void new_click_event(void): Informs that a new click has been detected.
		sem_post( &s ) ;
	}
	
	
Qust 5.12-

	// Variables 
	int event_count = 0 ;
	mutex_t mutex = MUTEX_INITIALIZER ;
	cond_t new_event = COND_INITIALIZER ;
	
	void get_new_click_event(){
		/*
		• 	void get_new_click(void): Returns only when a click event is available. By available,
			we mean that each click can be associated with a single call to get_new_click(). We also
			mean that no event is lost, that is, if there is a new click event while no thread is blocked in
			the get_new_click() function, then the next thread calling get_new_click() will not
			block.
		*/
		mutex_lock( &mutex );
		while( event_count == 0 ){
			cond_wait( &new_event , &mutex );
		} 
		event_count-- ;
		mutex_unlock( &mutex ) ;
	}
	
	void new_click_event(){
		// • void new_click_event(void): Informs that a new click has been detected.
		mutex_lock( &mutex ) ;
		event_count++ ;
		cond_signal( &new_event ) ;
		mutex_unlock( &mutex ) ;
	}




